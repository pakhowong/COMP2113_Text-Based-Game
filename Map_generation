#include <iostream>
#include <time.h>
#include <cstdlib>
#include <stdio.h>
using namespace std;

const int Max_map_width = 60, Max_map_height = 30;

// Game elements
int map[Max_map_height][Max_map_width]; // Initialise the 2-D array of map with the maximum map size allowed
char stage[Max_map_height][Max_map_width];
int location_x = 0, location_y = 0;
int treasure = 0, weapon = 0;

void refresh() {
    // Linux ONLY
    // To clear everything on the screen
    printf("\033c");
}

int select_difficulty() {
    int difficulty = 0;
    // Allow user to choose various difficulties (size of the map)
    while ((difficulty < 1) || (difficulty > 3)) {
        cout << "Please choose the levels of difficulty (1, 2 or 3):" << endl;
        cin >> difficulty;
    }
    return difficulty;
}

void generate_map(int height, int width) {
    int RNG;
    
    srand(time(0));
    for (int i = 0; i < height; i++) {
        for (int j = 0; j < width; j++) {
            RNG = rand();
            RNG = RNG % 5;
            //cout << RNG << " ";
            map[i][j] = RNG;  // Fill the map with either 1 or 0
            if (map[i][j] == 0) {
                map[i][j] = -1; // Change all 0 to -1 in order to facilitate the later checking of map vaidity
            }
            else if (map[i][j] != 0) {
                map[i][j] = 0;
            }
        }
    }

    // Set the start and end point
    map[0][0] = 1;
    map[height - 1][width - 1] = -2;
}

bool isMapValid(int height, int width) {
    int temp_map[Max_map_height][Max_map_width];
    
    // Create a copy of the map
    for (int i = 0; i < height; i++) {
        for (int j = 0; j < width; j++) {
            temp_map[i][j] = map[i][j];
        }
    }
    
    int steps = 1;
    int w = 0, h = 0;
    bool found = false, valid = false, exhaust = false;

    // Check if the map have "-2" (i.e. the goal) or not
    for (int i = 0; i < height; i++) {
        for (int j = 0; j < width; j++) {
            if (temp_map[i][j] == -2) {
                valid = true;
                break;
            }
        }
    }
    // For non-valid map (i.e. without goal), there will be no path to the goal
    if (not valid) {
        return 0;
    }

    while (valid && (not found) && (not exhaust)) {
        // Loop through the map to find the target node
        // i.e. "1" represet the starting point
        for (int i = 0; i < height; i++) {
            for (int j = 0; j < width; j++) {
                if (temp_map[i][j] == steps) {
                    h = i;
                    w = j;
                    
                    // Break the loop and return the number of steps if -2 (i.e. goal) is found
                    if (temp_map[h - 1][w] == -2) {
                        // Top
                        found = true;
                        break;
                    }
                    if (temp_map[h + 1][w] == -2) {
                        // Down
                        found = true;
                        break;
                    }
                    if (temp_map[h][w - 1] == -2) {
                        // Left
                        found = true;
                        break;
                    }
                    if (temp_map[h][w + 1] == -2) {
                        // Right
                        found = true;
                        break;
                    }

                    // Filling all neighbouring "0" nodes with (steps + 1)
                    if (temp_map[h - 1][w] == 0) {
                        temp_map[h - 1][w] = steps + 1;
                    }
                    if (temp_map[h + 1][w] == 0) {
                        temp_map[h + 1][w] = steps + 1;
                    }
                    if (temp_map[h][w - 1] == 0) {
                        temp_map[h][w - 1] = steps + 1;
                    }
                    if (temp_map[h][w + 1] == 0) {
                        temp_map[h][w + 1] = steps + 1;
                    }
                }
            }
        }
        steps++;

        // Check if all possibilities have been eliminated
        if (steps > (height * width)) {
            exhaust = true;
        }
    }

    // If a path could not be found after exhausting all efforts, return "No"
    if (exhaust) {
        steps = 0;
    }

    if ((steps - 1) > 0) {
        return true;
    }
    else {
        return false;
    }
}

void generate_game_items(int height, int width, int difficulty) {
    // -3 represents "treasures" while -4 represents "weapons" temporarily

    int temp_map[Max_map_height][Max_map_width];
    // Create a copy of the map
    for (int i = 0; i < height; i++) {
        for (int j = 0; j < width; j++) {
            temp_map[i][j] = map[i][j];
        }
    }
    
    bool treasure_is_generated = false, weapon_is_generated = false;
    int treasure_counter = 0, weapon_counter = 0;
    int RNG, probability;
    srand(time(0));

    switch(difficulty) {
        case 1:
            probability = 20;
            break;
        case 2:
            probability = 40;
            break;
        case 3:
            probability = 80;
            break;
    }
    
    while ((not treasure_is_generated) && (not weapon_is_generated)) {
        // Generate "treasures" (i.e. -3)
        if (not treasure_is_generated) {
            for (int i = 0; i < height; i++) {
                for (int j = 0; j < width; j++) {
                    RNG = rand();
                    RNG = RNG % probability; // Probability of generating a treasure
                    if (treasure_counter == 5) {
                        treasure_is_generated = true;
                        break;
                    }
                    if ((temp_map[i][j] == 0) && (RNG == 1)) {
                        temp_map[i][j] = -3;
                        treasure_counter++;
                    }
                }
            }
        }

        // Generate "weapons" (i.e. -4)
        if (not weapon_is_generated) {
            for (int i = 0; i < height; i++) {
                for (int j = 0; j < width; j++) {
                    RNG = rand();
                    RNG = RNG % probability; // Probability of generating a weapon
                    if (weapon_counter == 5) {
                        weapon_is_generated = true;
                        break;
                    }
                    if ((temp_map[i][j] == 0) && (RNG == 1)) {
                        temp_map[i][j] = -4;
                        weapon_counter++;
                    }
                }
            }
        }

        if (treasure_is_generated && weapon_is_generated) { // Check if enough game items are generated
            // Copy the temporary map back to the "master" map
            for (int i = 0; i < height; i++) {
                for (int j = 0; j < width; j++) {
                    map[i][j] = temp_map[i][j];
                }
            }
        }
    }
}

void generate_stage (int height, int width) {
    // Represent the game objects in characters instead of integers
    stage[0][0] = 'P';
    stage[height - 1][width - 1] = 'B';
    for (int i = 0; i < height; i++) {
        for (int j = 0; j < width; j++) {
            if (map[i][j] == 0) {
                stage[i][j] = '.';
            }
            else if (map[i][j] == -1) {
                stage[i][j] = 'x';
            }
            else if (map[i][j] == -3) {
                stage[i][j] = 'T';
            }
            else if (map[i][j] == -4) {
                stage[i][j] = 'W';
            }
        }
    }
}

void showstage(int height, int width) {
    refresh();
    //cout << location_x << " " << location_y << endl;

    cout << "###############" << endl;
    cout << "# " << "Treasure: " << treasure << " #" << endl;
    cout << "# " << "Weapon:   " << weapon << " #" << endl;
    cout << "###############" << endl << endl;

    for (int i = 0; i < width; i++) {
        cout << "##";   // "#" is the map boundary
    }
    cout << "##" << endl;
    for (int i = 0; i < height; i++) {
        cout << "#";
        for (int j = 0; j < width; j++) {
            cout << stage[i][j] << " ";
        }
        cout << "#" << endl;
    }
    for (int i = 0; i < width; i++) {
        cout << "##";
    }
    cout << "##" << endl;
}

void move(int height, int width) {
    char input;
    cin >> input;
    switch(input) {
        case 'w':
            // Move up
            if ((location_x - 1) >= 0) {
                if (stage[location_x - 1][location_y] != 'x') {
                    if (stage[location_x - 1][location_y] == 'T') {
                        treasure++;
                    }
                    else if (stage[location_x - 1][location_y] == 'W') {
                        weapon++;
                    }
                    stage[location_x][location_y] = '.';
                    stage[location_x - 1][location_y] = 'P';
                    location_x--;
                }
            }
            break;
        case 'a':
            // Move left
            if ((location_y - 1) >= 0) {
                if (stage[location_x][location_y - 1] != 'x') {
                    if (stage[location_x][location_y - 1] == 'T') {
                        treasure++;
                    }
                    else if (stage[location_x][location_y - 1] == 'W') {
                        weapon++;
                    }
                    stage[location_x][location_y] = '.';
                    stage[location_x][location_y - 1] = 'P';
                    location_y--;
                }
            }
            break;
        case 's':
            // Move down
            if ((location_x + 1) <= (height - 1)) {
                if (stage[location_x + 1][location_y] != 'x') {
                    if (stage[location_x + 1][location_y] == 'T') {
                        treasure++;
                    }
                    else if (stage[location_x + 1][location_y] == 'W') {
                        weapon++;
                    }
                    stage[location_x][location_y] = '.';
                    stage[location_x + 1][location_y] = 'P';
                    location_x++;
                }
            }
            break;
        case 'd':
            // Move right
            if ((location_y + 1) <= (width - 1)) {
                if (stage[location_x][location_y + 1] != 'x') {
                    if (stage[location_x][location_y + 1] == 'T') {
                        treasure++;
                    }
                    else if (stage[location_x][location_y + 1] == 'W') {
                        weapon++;
                    }
                    stage[location_x][location_y] = '.';
                    stage[location_x][location_y + 1] = 'P';
                    location_y++;
                }
            }
            break;
    }
}

bool isGoal(int height, int width) {
    if ((location_x == (height - 1)) && (location_y == (width - 1))) {
        return true;
    }
    else {
        return false;
    }
}

void boss_stage() {
    refresh();
    cout << "BOSS STAGE!!!" << endl;
}

int main() { 
    int difficulty = select_difficulty();
    int height = 0, width = 0;
    switch(difficulty) {
        case 1:
            width = 20;
            height = 10;
            break;
        case 2:
            width = 30;
            height = 15;
            break;
        case 3:
            width = 40;
            height = 20;
            break;
    }

    do {
        generate_map(height, width);
    }
    while (not isMapValid(height, width));

    generate_game_items(height, width, difficulty);
    generate_stage(height, width);

    showstage(height, width);

    while (not isGoal(height, width)) {
        move(height, width);
        showstage(height, width);
    }

    boss_stage();

    return 0;
}
